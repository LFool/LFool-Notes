# 对象的创建

本篇文章的标题虽然是「对象创建」，但内容却不仅仅只有对象的创建，以对象的创建为主线，展开对 Java 堆的详细整理总结！！

其中包括：堆的内存结构、对象的内存布局、对象创建过程、对象内存分配过程。其中「堆的内存结构」和「对象内存分配过程」可能会涉及到一些垃圾收集的内容！

### <font color=#1FA774>堆的内存结构</font>

首先来梳理一下「堆」「**[虚拟机栈](./虚拟机栈.html)**」「**[方法区](./方法区.html)**」三者之间的关系：

![6](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221112/16581716682434979vujO06.svg)

**<font color='red'>注意：</font>**到了 JDK7 的 HotSpot，已经把原本放在永久代的**字符串常量池**、**静态变量**等移至 Java 堆中 (上图方法区为 JDK7 之前的布局)

在文章 **[运行时数据区域](./运行时数据区域.html#分配内存角度)** 说过：**为了更好地回收内存，或是更快地分配内存，可以将堆划分成不同的区域**

但随着技术的发展，可能有些虚拟机并没有采用分代的思想，但抱着学习的目的，本人的总结主要还是围绕 HotSpot 基于「经典分代」的内存划分，主要分两个阶段 (-∞, JDK7] 和 [JDK8, +∞) 展开讨论

在 JDK7 及以前，堆内存逻辑上分为三个部分：新生代 + 老年代 + **永久代**

在 JDK8 及以后，堆内存逻辑上分为三个部分：新生代 + 老年代 + **元空间**

![8](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221112/1906331668251193xJJaK08.svg)

**约定：**

- 新生代 <-> 新生区 <-> 年轻代
- 养老区 <-> 老年区 <-> 老年代
- 永久区 <-> 永久代

通过上面的图可以知道：方法区不属于堆；不同版本的 JDK，方法区的实现上有一些不同，在 JDK7 及以前使用永久代的实现方式，而在 JDK8 及之后使用元空间的实现方式

本篇文章主要讨论 Java 堆，所以**方法区详细介绍可见 [方法区](./方法区.html)**

堆分为「新生代」和「老年代」，它们俩默认的比例是 1 : 2，可以通过参数`-XX:newRatio`配置新生代与老年代在堆结构的占比

新生代又分为「Eden 区」「Survivor1 区」「Survivor2 区」，它们仨默认的比例是 8 : 1 : 1，可以通过参数`-XX:SurvivorRatio`设置新生代中 Eden 和 S0/S1 空间的比例

虽然新生代被划分为 3 个区域，其比例为 8 : 1 : 1，但两个 Survivor 区始终只有一个被使用，所以往往提到新生代大小时表示 Eden 区和一个 Survivor 区的和

**上面的划分是为了更好的回收内存，至于为什么可以更好的回收内存，详情可见 [垃圾收集算法](./垃圾收集算法.html)**

### <font color=#1FA774>对象内存布局</font>

一个对象是根据相应的类生成的，如`Object obj = new Object()`；而一个类中主要包含：常量、类变量 (静态变量)、实例变量、方法

有些东西属于类，而非对象；换句话说，有些东西所有对象都一样，比如：常量、类变量、方法

所以也就没必要为每个对象都花内存空间去存储这些东西，而是采用一种共享的思想，把这些属于类的东西专门存放在一个地方，每个对象中就不用存了，直接在对象中用一个指针指向这些属于类的数据即可

说了这么多，其实是为了说明：对象中不会存属于类的数据，只有**实例数据**。除此之外，还有**对象头**和**对齐填充**

在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头 (Header)、实例数据 (Instance Data)、对齐填充 (Padding)，如下图所示：

![8](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221113/2132061668346326yb6FMc8.svg)

#### <font color=#9933FF>对象头</font>

如上图所示，对象头分为三个部分，第三个部分是可选滴！

**<font color='red'>Mark Word</font>**

该部分用于存储对象自身的**运行时数据**，如：哈希码 (HashCode)、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等 (PS：虽然有些名词不知道啥意思，以后会慢慢补充！！)

不同位数的虚拟机该部分的长度不一样，32 位和 64 位虚拟机分别对应 32 bit 和 64 bit。在实际中对象需要存储的运行时数据很多，其实已经超过了 32 或者 64 位，但是 Mark Word 被设计成一个有着**动态定义的数据结构**，以便在更小的空间内存储尽量多的数据，**<font color='red'>根据对象的状态复用自己的存储空间</font>**

以 32 bit 为例，对象的存储内容如下图所示：

![9](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221113/2208461668348526wCfnAt9.svg)

在上图中挑两个概念解释一下 (因为目前只会两个，哈哈哈哈)

先来介绍对象的 HashCode，肯定听过一个问题：**为什么重写 equals() 的同时还得重写 hashCode() ？**

重写前调用 hashCode() 方法返回的值和对象头中存储的 HashCode 值是相同的；但如果重写了该方法，那就不一样了

而且只有在对象调用了计算哈希的函数后，HashCode 才会被存储在 object header 中，下次直接从对象头中取即可；反之如果没有调用，则对象头中 HashCode 值为 0

**关于 HashCode 更详细的内容可见 [「equals」「hashCode」](./equals-hashCode.html)**

再来介绍对象的 GC 分代年龄，这个值的作用是在 Minor GC 时，判断 Survivor 区的对象是否需要晋升到老年代中 (默认最大年龄为 15，大于该值就需要晋升到老年代)

一个对象刚刚创建时，age = 0，之后每进行一次 GC，age 就会 +1

**<font color='red'>Class Pointer</font>**

该部分时类型指针，即对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例

但是并非所有的虚拟机实现都必须在这个对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，还可以通过**句柄**访问 (后面会介绍)

**<font color='red'>Array Length</font>**

此外，如果对象是一个 Java 数组，那么在对象头中还必须有一块用于记录数组长度的数据

因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小；但是如果数组的长度是不确定的，将无法通过元数据的信息推断出数组的大小

#### <font color=#9933FF>实例数据</font>

该部分才是对象真正存储的有效信息，即在程序中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来

这部分存储顺序会受到虚拟机分配策略参数和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配顺序为：long/double、int、short、char、byte/boolean、oop

从上面默认的分配顺序可以看出相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前

如果 HotSpot 虚拟机的`+XX:CompactFields`参数值为 true (默认就为 true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间

#### <font color=#9933FF>对齐填充</font>

该部分是对齐填充，并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用

由于 HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节 (32 bit) 的整数倍，换句话说，任何对象的大小都必须是 8 字节的整数倍

对象头部已经被精心设计成正好是 8 字节的倍数 (1 倍 or 2 倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全

#### <font color=#9933FF>实战分析</font>

介绍完了对象的内存布局，用一个小程序来直观的看一看，也可以验证一下到底对不对！！

首先需要添加一个 Maven 依赖：

```xml
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.16</version>
</dependency>
```

下面给出测试小程序：

```java
public class TestGCAge {
    public static void main(String[] args) throws InterruptedException {
        Person p = new Person();
        // 不调用 hashCode() 不会记录哈希码
        int hashCode = p.hashCode();
        // 转 16 进制输出，与头信息中 HashCode 进行比较
        String hex = Integer.toHexString(hashCode);
        System.out.println("HashCode 十六进制: "+ hex);
        System.gc();
        print(p);
    }
    // 输出对象
    static void print(Person p){
        System.err.println(ClassLayout.parseInstance(p).toPrintable());
    }
}

class Person{
    private boolean flag;
}
```

下面是结果：

```java
HashCode 十六进制: 4aa298b7                                                                   // 没有重写 hashCode() 方法时返回的值，和 header 中的相同
com.lfool.myself.Person object internals:
OFF  SZ      TYPE DESCRIPTION               VALUE
  0   8           (object header: mark)     0x0000 004a a298 b709 (hash: 0x4aa298b7; age: 1) // 8 个字节保存 mark word；进行了一次 GC，年龄 +1
  8   4           (object header: class)    0x00060a20                                       // 4 个字节保存 class pointer
 12   1   boolean Person.flag               false                                            // 1 个字节保存 boolean 类型实例变量
 13   3           (object alignment gap)                                                     // 3 个字节对齐填充
Instance size: 16 bytes
Space losses: 0 bytes internal + 3 bytes external = 3 bytes total
```

下面尝试不调用`hashCode()`方法，也不调用系统 GC，直接调用上述代码中的`print()`方法，重新看看对象的布局：

```java
com.lfool.myself.Person object internals:
OFF  SZ      TYPE DESCRIPTION               VALUE
  0   8           (object header: mark)     0x0000000000000001 (non-biasable; age: 0)        // hashCode 和 age 都为 0
  8   4           (object header: class)    0x00060a20
 12   1   boolean Person.flag               false
 13   3           (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 3 bytes external = 3 bytes total
```

### <font color=#1FA774>对象访问定位</font>

创建对象是为了后续的使用，Java 程序会通过栈上的 reference 类型数据来操作堆上的具体对象

但是《Java 虚拟机规范》只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式由两种：

- 通过句柄方法：Java 堆中将可能划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息
- 通过直接指针访问：Java 堆中对象的内存布局就必须考虑如何如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问开销

上述两种方式的结构如下图所示：

![10](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221114/1601471668412907MJDOIm10.svg)

这两种方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是**<font color='red'>稳定</font>**的句柄地址，在对象移动 (GC 时会发生移动) 时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改

使用直接指针来访问最大的好处就是**<font color='red'>速度更快</font>**，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本

对于 HotSpot 虚拟机而已，它主要使用**直接指针**进行对象访问，但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况也十分常见！！

### <font color=#1FA774>对象创建过程</font>

扯了这么多「堆的内存结构」、「对象的内存结构」、「对象的访问定位」，那一个对象的创建过程到底是什么样的呢？本部分就来详细介绍一个对象从 0 到 1 的详细过程，先给一张完整的流程图：

![11](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221114/1628231668414503YR0aFO11.svg)

#### <font color=#9933FF>类加载检查</font>

当 Java 虚拟机遇到一条字节码`new`指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，那必须先执行相应的类加载过程。**关于类加载过程详细内容可见 [类加载的过程](./类加载的过程.html)**

#### <font color=#9933FF>分配内存</font>

在类检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配内存的任务实际上等同于把一块确定大小的内存块从 Java 堆中划分出来

根据 Java 堆中内存是否规整，可以有两种不同的分配方式：

- **指针碰撞 (内存规整)**：将所有已使用的内存和未使用的内存分两边，中间用一个指针作为分界点指示器，分配内存的过程是把指针向空闲空间方向娜动一段与对象大小相等的距离
- **空闲列表 (内存不规整)：**维护一个列表，记录可用空闲内存块，分配内存的过程是从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

选择内存分配方式，要根据内存是否规整来决定；而内存是否规整，又和所采用的垃圾收集器是否带有空间压缩整理的能力有关。**关于垃圾收集算法的详细内容可见 [垃圾收集算法](./垃圾收集算法.html)**

为对象分配内存，除了如何划分可用空间之外，还有一个需要思考的问题：**<font color='red'>对象创建操作十分频繁，每次并非只有一个线程申请分配空间，在并发情况下这个过程线程不安全</font>**

根据上面介绍的两种分配方式可以知道每一次分配过程至少对应两个步骤：一、根据原指针位置找到合适的内存空间；二、修改指针

可能出现正在给对象 A 分配内存，指针还没有来得及修改；对象 B 又同时使用了原来的指针来分配内存

解决上面的线程安全问题有两种可选方案：

- 对分配内存空间的动作进行同步处理，采用「CAS + 失败重试」的方式保证更新操作的原子性
- 每个线程在 Java 堆中预先分配一小块内存 (TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有缓冲区用完了，分配新的缓冲区时才需要同步锁定

#### <font color=#9933FF>初始化零值</font>

内存分配完成之后，虚拟机必须将分配到的内存空间 (不包括对象头) 都初始化为零值，如果使用了 TLAB 的话，这一项工作可以提前到 TLAB 分配时进行

这一步操作保证了对象的**<font color='red'>实例字段</font>**在 Java 代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值

**<font color='red'>注意：</font>**局部变量必须赋初始值，否则编译不通过！

#### <font color=#9933FF>设置对象头</font>

这一部分主要是设置对象头，如：

- 对象所对应的类元数据信息
- 对象 HashCode (HashCode 的计算会延后到调用`Object::hashCode()`方法时)
- 对象 GC 年龄分代
- ......

#### <font color=#9933FF>执行构造函数</font>

到此为止，从虚拟机的角度来看，一个新的对象已经产生；但是从程序员的角度来看，对象的创建才刚刚开始！！

此时对象中的实例字段还都只是零值，并没有按照程序员的意图构造好。一般来说，`new`指令之后会接着执行`<init>()`方法，按照程序员的意愿对对象进行初始化

完成了上面所有的步骤后，这样一个真正可用的对象才算完全被构造出来！！

### <font color=#1FA774>对象内存分配与回收策略</font>

#### <font color=#9933FF>对象优先在 Eden 分配</font>



#### <font color=#9933FF>大对象直接进入老年代</font>

#### <font color=#9933FF>长期存活的对象将进入老年代</font>

#### <font color=#9933FF>动态对象年龄判定</font>

#### <font color=#9933FF>空间分配担保</font>
