# 垃圾回收相关概念

### <font color=#1FA774>Stop The World</font>

Stop The World，简称 STW，指在 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程会被暂停，没有任何响应

被 STW 中断的应用线程会在 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡顿一样，所以需要减少 STW 发生的时间

可达性分析算法中枚举 GC Roots 时会导致所有 Java 执行线程停顿，原因如下：

- 分析工作必须在一个能保证一致性的快照中进行
- 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
- 如果分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

**<font color='red'>注意：</font>**STW 和使用哪款 GC 无关，所有的 GC 都会产生 STW，只能说效率越高的 GC，STW 的时间越短，但并不是没有 STW，我们能做的也只是尽可能的缩短 STW 的时间，如：增量收集算法和分区收集算法

STW 是 Java 虚拟机在后台自动发起和自动完成的，在用户不可见的情况下，把用户的工作线程全部停掉；开发中不要用`System.gc()`，会导致 STW 的发生

### <font color=#1FA774>并行与并发</font>

#### <font color=#9933FF>程序中的并行与并发</font>

**<font color='red'>并行：</font>**一般指多核处理器，每个线程都单独在一个核心上运行，各线程之间不存在资源竞争的关系

**<font color='red'>并发：</font>**一般指单核处理器，多个线程都在同一个核心上运行，但一个核心同一时刻只能执行一个线程，所以各线程之间交替执行，常见的有时间片轮询算法

对于并行，宏观上多个线程之间都在同时执行；微观上多个线程之间也都在同时执行，没有 CPU 资源的竞争

对于并发，宏观上多个线程之间都在同时执行；微观上多个线程之间交替执行，同一时刻只有一个线程在执行，存在 CPU 资源的竞争

#### <font color=#9933FF>垃圾回收的并行与并发</font>

**<font color='red'>并行：</font>**描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此用户线程处于等待状态

典型的 ParNew 就是多线程并行的垃圾收集器，与之相对应的是 Serial 单线程串行垃圾收集器，它们俩运行示意图如下所示：

![7](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221127/1842041669545724OMNW6q7.svg)

**<font color='red'>并发：</font>**描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行 (不一定并行，可能是交替执行)。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序处理的吞吐量将受到一定影响

典型的 CMS 就是并发的垃圾收集器，其中初始标记、重新标记两个步骤仍然需要 STW，其它步骤可以和用户线程一起并行执行，它的运行示意图如下所示：

![8](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221127/1842231669545743AykCyq8.svg)

**<font color='red'>总结：</font>**为了提高垃圾回收的效率，GC 经历了「串行回收 -> 并行回收 -> 并发回收」

- 串行的效率最慢，只有一个 GC 线程，而且用户线程还必须 STW 等待一次完整的 GC 过程执行完成，这样用户感受到的停顿感会十分明显
- 并行在串行的基础上将一个 GC 线程增加到多个 GC 线程，虽然回收的效率会提高一些，但是用户线程依旧必须 STW 等待一次完整的 GC 过程执行完成
- 并发在并行的基础上再度升级，不仅拥有多个 GC 线程，而且用户线程和 GC 线程都在运行 (可能交替执行)，虽然必要阶段可能还是需要 STW，但用户体验感明显会好很多
