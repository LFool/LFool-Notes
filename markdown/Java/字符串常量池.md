# 字符串常量池

前文介绍了 **[运行时常量池](./运行时常量池.html)**，它和本篇文章要介绍的「字符串常量池」是包含关系

在 JDK7 及以后，字符串常量池被挪到了 Java 堆中，但这并不影响它的作用，只是位置发生了变化

### <font color=#1FA774>String 类</font>

通过名字，第一印象很容易看出来，「字符串常量池」就是专门用来存放字符串的常量池，所以先来介绍一下`String`类

**<font color='red'>注意：</font>**下面出现的代码大多都是从源码中摘出来的！有兴趣的可以结合`String`源码一起观看！！

首先需要明确的是`String`是一个`final`类：

```java
// String 类不能被继承
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    // ...
}
```

其次需要知道的是`String`中存储数据的结构是一个`char[]`数组：

```java
// private + final 让 String 对象不可变，这是实现字符串常量池的基础！！
private final char value[];
```

最后介绍四种创建字符串对象的方法：

```java
String s1 = "abc";                     // 方法 1
String s2 = String.valueOf("abc");     // 方法 2
String s3 = new String("abc");         // 方法 3
char[] chars = {'a', 'b', 'c'};
String s4 = new String(chars);         // 方法 4
```

### <font color=#1FA774>初级比较</font>

**关于对象引用直接用`= =`比较的详细分析可见 [「equals」「hashCode」](./equals-hashCode.html)**

接着上一部分，如果`s1`直接和`s2, s3, s4`用`= =`做比较，结果会如何？具体代码如下：

```java
// 省略前面代码 ...
System.out.println(s1 == s2);  // true
System.out.println(s1 == s3);  // false
System.out.println(s1 == s4);  // false
```

首先通过 JProfiler 软件，查看一下这些对象在堆中的结构，如下图所示：

<img src="https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221119/1511311668841891xUD3sV8.svg" alt="8" style="zoom: 40%;" />

上图对应的可视化解释如下图所示：

![7](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221119/1530371668843037yH7qpI7.svg)

对于`String s1 = "abc"`来说，它就是一个字符串对象，有一个字符数组类型的字段`value`，存储实际的数据。**<font color='red'>所有双引号`"xxx"`中的内容都在字符串常量池中！！</font>**所以`"abc"`在字符串常量池中，更准确一点，是地址为`0xb5d`的字符串对象在字符串常量池中

对于`String s2 = String.valueOf("abc")`来说，先看一下`valueOf()`方法，如下所示：

```java
public static String valueOf(Object obj) {
    // toString() 见下方
    return (obj == null) ? "null" : obj.toString();
}
public String toString() {
    return this;
}
```

可以看到，如果传入的参数是一个字符串对象，该方法就是把传入的对象返回了，所以方法 2 和方法 1 是等价的！

对于`String s3 = new String("abc")`来说，先看一下对应的构造函数，如下所示：

```java
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
```

可以看到，将传入参数的`value`和`hash`字段赋值给自身的`value`和`hash`字段。举个很形象的例子，如果传入的对象是羊，那么`new`出来的新对象就是披着狼皮的羊

对于`String s4 = new String(chars)`来说，同样的，先看一下对应的构造函数，如下所示：

```java
public String(char value[]) {
    this.value = Arrays.copyOf(value, value.length);
}
```

上面说过，`String`对象存储数据的结构是一个`char[]`数组，所以这个构造函数相当于把传入的数组 copy 了一份，然后赋值给自身的`value`字段

**<font color='red'>综上所述：</font>**如果只是给`value`和`hash`字段赋了相同的值，但对象还是不同的；用`= =`直接比较，比较的是对象的地址是否相同！！

**<font color='red'>扩展：</font>**继续看一下用`equals()`方法比较的原理，源码如下所示：

```java
public boolean equals(Object anObject) {
    // 现在直接比较两个对象地址。如果地址相同，肯定相等
    if (this == anObject) {
        return true;
    }
    // 看看比较的两个对象类型是否相同。如果不同，直接返回 false
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            // 可以看到比较的是两个对象的 value 字符数组是否相同 
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

### <font color=#1FA774>高级比较</font>

上面的初级比较中，都是简单直接给出一个完整字符串，这一部分介绍几种高级比较！！

#### <font color=#9933FF>字符串拼接赋值</font>

两个字符串直接拼接在一起的情况！

```java
String s1 = "abcdef";
String s2 = "abc" + "def";
System.out.println(s1 == s2);  // true
```

通过 JProfiler 软件发现 Java 堆中并没有`"abc"`和`"def"`，只有`"abcdef"`，为什么会这样呢？？

通过`javap`反编译 Class 文件后，发现常量池中只有`abcdef`；为`s2`赋值时，也是直接把`abcdef`赋给了`s2`，并没有拼接的过程，具体如下所示：

```java
// 部分常量池
#30 = Utf8               abcdef
// 为 s2 赋值的字节码指令 
3: ldc           #2                  // String abcdef
5: astore_2
```

这是因为在编译阶段，进行了一波优化！！不仅是字符串，整型常量也是如此，如下所示：

```java
// 源码
int a = 5 + 6;
// 为 a 赋值的字节码指令 
0: bipush        11
2: istore_1
```

#### <font color=#9933FF>字符串和变量的拼接赋值</font>

**<font color='red'>例子一</font>**

```java
String s1 = "abc";
System.out.println(s1 + "def" == "abcdef");  // false
```

首先可以知道编译阶段没有进行和上面一样的优化，而且从底层来看，此处的拼接是借助`StringBuilder`完成的，上面代码和下面的代码等价 (编译后的字节指令完全一样)：

```java
String s1 = "abc";
System.out.println(new StringBuilder().append(s1).append("def").toString() == "abcdef"); // false
```

下面给出编译后的字节码指令：

```java
Code:
  stack=3, locals=1, args_size=0
     0: ldc           #2                  // String abc
     2: astore_0
     3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
     6: new           #4                  // class java/lang/StringBuilder
     9: dup
    10: invokespecial #5                  // Method java/lang/StringBuilder."<init>":()V
    13: aload_0
    14: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
    17: ldc           #7                  // String def
    19: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
    22: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
    25: ldc           #9                  // String abcdef
    27: if_acmpne     34
    30: iconst_1
    31: goto          35
    34: iconst_0
    35: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V
    38: return
```

上面从字节码的角度分析了**等价性**，下面从内存的角度分析为什么不相等！

首先搞清楚哪些字符串在**字符串常量池**中，在字符串常量池的有：`"abc", "def", "abcdef"`，通过 JProfiler 验证如下：

<img src="https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221119/1722001668849720ykUYmf8.svg" alt="8" style="zoom:67%;" />

然后在看看看`StringBuilder::toString`的源码：

```java
@Override
public String toString() {
    // Create a copy, don't share the array
    return new String(value, 0, count);
}
public String(char value[], int offset, int count) {
    if (offset < 0) {
        throw new StringIndexOutOfBoundsException(offset);
    }
    if (count <= 0) {
        if (count < 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        if (offset <= value.length) {
            this.value = "".value;
            return;
        }
    }
    // Note: offset or count might be near -1>>>1.
    if (offset > value.length - count) {
        throw new StringIndexOutOfBoundsException(offset + count);
    }
    // copy 了一份！！
    this.value = Arrays.copyOfRange(value, offset, offset+count);
}
```

`StringBuilder`中也是用`char[] value`来存储字符，而`StringBuilder::toString`方法会调用`String`的构造函数`public String(char value[], int offset, int count)`

这个构造函数是 copy 了一份`value`字符数组，而不是直接把`value`赋值给自身，和`public String(char value[])`差不多，注意和`public String(String original)`区分！！

可视化解释如下图所示：

![9](https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221119/1939521668857992YreKDY9.svg)

**<font color='red'>例子二</font>**

下面再给一个稍微特殊的例子：

```java
final String s1 = "abc";
String s2 = s1 + "def";
System.out.println(s2 == "abcdef");  // true
```

唯一的不同在于`s1`前面被`final`修饰，`s1`是常量，不能再指向其他字符串对象

首先搞清楚编译后**常量池**中有什么，常量池的有：`"abc", "abcdef"`，并没有`"def"`。顺便看一下编译后的字节码指令：

```java
Code:
  stack=3, locals=3, args_size=1
     0: ldc           #2                  // String abc
     2: astore_1
     3: ldc           #3                  // String abcdef
     5: astore_2
     6: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
     9: ldc           #2                  // String abc
    11: aload_2
    12: if_acmpne     19
    15: iconst_1
    16: goto          20
    19: iconst_0
    20: invokevirtual #5                  // Method java/io/PrintStream.println:(Z)V
    23: return
```

我们发现这个时候的拼接并没有像上面那样借助`StringBuilder`，甚至连拼接的过程都没有发现，都没有看到`"def"`，这是为什么呢？

肯定和`final`修饰有关 (废话)，被`final`修饰后，`s1`是常量，而`"def"`也是常量

所以直接在编译阶段通过优化把`s1 + "def"`的结果计算出来了，这也是为什么常量池中没有`"def"`，但是有`"abcdef"`的原因

那为什么上一个例子不能这样处理呢？！上面一个例子中`s1`不是常量，编译阶段并不能知道`s1`到底指向哪一个字符串对象，只有在运行期间才能知道！！！

#### <font color=#9933FF>字符串和引用拼接赋值</font>

```java
String s1 = "abc" + new String("def");
System.out.println(s1 == "abcdef");  // false
```

这个和上面 **[字符串和变量的拼接赋值](./字符串常量池.html#字符串和变量的拼接赋值)** 的第一个例子差不多，字节码层面都是通过`StringBuilder`拼接，如下所示：

```java
Code:
  stack=4, locals=2, args_size=1
     0: new           #2                  // class java/lang/StringBuilder
     3: dup
     4: invokespecial #3                  // Method java/lang/StringBuilder."<init>":()V
     7: ldc           #4                  // String abc
     9: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
    12: new           #6                  // class java/lang/String
    15: dup
    16: ldc           #7                  // String def
    18: invokespecial #8                  // Method java/lang/String."<init>":(Ljava/lang/String;)V
    21: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
    24: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
    27: astore_1
    28: getstatic     #10                 // Field java/lang/System.out:Ljava/io/PrintStream;
    31: aload_1
    32: ldc           #11                 // String abcdef
    34: if_acmpne     41
    37: iconst_1
    38: goto          42
    41: iconst_0
    42: invokevirtual #12                 // Method java/io/PrintStream.println:(Z)V
    45: return
```

#### <font color=#9933FF>引用拼接赋值</font>

```java
String s1 = new String("abc") + new String("def");
System.out.println(s1 == "abcdef");  // false
```

原因同上，可以看反编译后的字节码指令，通过`StringBuilder`拼接，为了节约篇幅，这里就不贴出来了！

### <font color=#1FA774>intern() 方法</font>

**<font color='red'>`intern()`方法会把首次遇到的字符串实例复制到「字符串常量池」中存储，返回的也是「字符串常量池」中这个字符串的实例引用 -> 「首次遇到」原则</font>**

```java
public class RuntimeConstantPoolOOM {
    public static void main(String[] args) throws InterruptedException {
        String str1 = new StringBuilder("计算机").append("软件").toString();
        System.out.println(str1.intern() == str1);

        String str2 = new String("ja") + new String("va");
        System.out.println(str2.intern() == str2);
    }
}
```

这里分三种情况讨论，分别在 JDK6、JDK7、JDK8 的版本下 (是不是很麻烦！)

**JDK6**

- 字符串常量池在永久代，永久代在方法区，属于非堆中
- `str1`和`str2`引用的对象实例都在 Java 堆中
- `str1.intern()`和`str2.intern()`返回的是方法区中的字符串常量池里的实例引用
- 所以两个都是`false`

**JDK7**

- 字符串常量池移到了 Java 堆中
- `str1.intern()`和`str2.intern()`返回的是 Java 堆中的字符串常量池里的实例引用
- 但由于`"java"`会在一开始就被加载到字符串常量池中，所以调用`str2.intern()`方法时并非首次遇到，返回的是一开始就被加载到字符串常量池中实例引用，和`str2`是不同的
- 所以第一个会得到`true`，第二个会得到`false`

**JDK8**

- 和 JDK7 基本一样，但不同在于`"java"`一开始**不会**被加载到字符串常量池中，所以调用`str2.intern()`方法时是首次遇到，返回的实例引用和`str2`相同
- 所以两个都是`true`

这里详细解释一下`"java"`字符串为什么一开始会被加载到字符串常量池中

在`sun.misc.Version`类中有一个静态常量，如下所示：

```java
// JDK7
public class Version {
    // ...
    private static final String launcher_name = "java";
    // ...
}
```

HotSpot VM 会在初始化过程中主动触发`java.lang.System`类的加载和初始化，过程中会调用到`java.lang.System.initializeSystemClass()`静态方法：

```java
private static void initializeSystemClass() {
    // ...
    sun.misc.Version.init();
    // ...
}
```

所以`sun.misc.Version`类会被加载到内存中，静态常量会被加载到字符串常量池中！！但是在 JDK8 的时候，这个地方有点变化，如下所示：

```java
// JDK8
public class Version {
	private static final String launcher_name = "openjdk";
}
```

**关于这个内容的详细解释可见 [如何理解《深入理解java虚拟机》第二版中对String.intern()方法的讲解中所举的例子？ - RednaxelaFX的回答 - 知乎](https://www.zhihu.com/question/51102308/answer/124441115)**

再来一个例子：

```java
String str1 = new StringBuilder().append("计算机软件").toString();
System.out.println(str1.intern() == str1);  // false
```

上文强调过「所有双引号`"xxx"`中的内容都在字符串常量池中！！」所以`"计算机软件"`在字符串常量池中，调用`str2.intern()`方法时字符串常量池中已经有了，返回的实例引用和`str1`是不同的

上个例子中`String str1 = new StringBuilder("计算机").append("软件").toString()`，`"计算机"`和`"软件"`都在字符串常量池中，但`"计算机软件"`不在

### <font color=#1FA774>对 String 不可变的理解</font>

#### <font color=#9933FF>理解一</font>

```java
String s = "abc";  // 第一步
s += "def";        // 第二步
s += "ghi";        // 第三步
```

首先，字符串常量池中有三个字符串：`"abc", "def", "ghi"`。当执行到每一步时，`s`对应的实例引用如下图所示：

<img src="https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20221120/0120251668878425MLJrlO11.svg" alt="11" style="zoom:90%;" />

这里的`+=`其实是一种字符串拼接，字节码指令层面的原理和 **[字符串和变量的拼接赋值](./字符串常量池.html#字符串和变量的拼接赋值)** 相同！！

从上图可以看出，拼接的过程，变化的只有`s`的值 (引用)，对于字符串对象本身来说并没有改变，每次都是生成了一个新的字符串对象

值的注意的是，上图中的**<font color='#6600CC'>紫色箭头</font>**是不可以变的，因为`String`类中的`value`字段被`final`修饰，所以值 (引用) 不可变，源码如下：

```java
private final char value[];
```

#### <font color=#9933FF>理解二</font>

若在**「理解一」**的基础上稍加修改，如下所示：

```java
final String s = "abc";
s += "def";   // 错误，编译不通过 ❌
s += "ghi";   // 错误，编译不通过 ❌
```

原理和**「理解一」**中一样，由于`s`被`final`修饰，所以值 (引用) 不可变，对应上图中就是**<font color='red'>红色箭头</font>**是不可以变的

#### <font color=#9933FF>理解三</font>

给出一段代码，想想会输出什么：

```java
public static void f1(String s) {
    s = "def";
}
public static void f2(char[] cs) {
    cs[0] = 'A';
}
public static void main(String[] args) {
    String s = "abc";
    char[] cs = new char[] {'a', 'b', 'c'};
    f1(s);
    f2(cs);
    System.out.println(s);    // abc
    System.out.println(cs);   // Abc
}
```

在学习 C 语言的时候，肯定听过「传值」或「传引用」；Java 中也有类似的东西，但 Java 中的本质都是「传值」

如果将变量按照数据类型划分的话，可以分为两类：

- **基本数据类型：**记录的是基本数据类型的值
- **引用数据类型：**记录的是对象的引用 (地址)，可以通过该引用找到对象

之所以说 Java 中的本质都是「传值」，因为如果传的是一个基本数据类型，那就是值；如果传的是一个引用数据类型，那就是引用，其实也就是该变量的值

回到上面的代码，先解释`s`为什么没变？！

- 我们只是把`f1`中的局部变量`s`的引用指向了另外一个对象 (等价于修改了上图中的**<font color='red'>红色箭头</font>**)，那关`main`中的局部变量`s`什么事情！！！
- 因为只是把`main`中的局部变量`s`的值传给了`f1`，`f1`中无论怎么修改它，都不会影响`main`中的局部变量`s`

再解释`cs`为什么变了？！

- `cs[i] = 'x'`表示把相对起始地址偏移量为`i`的地址的值改为`'x'`
- 和上面的不同点在于此时是根据地址修改了值，上面只是修改了引用的值

#### <font color=#9933FF>理解四</font>

假设`String`类中`value`字段不是`private`，即可以任意访问修改，会怎么样呢？下面我们来试试！！

可以通过**反射机制**访问或修改无权限的字段，**关于操作运行时类的内部属性及方法的详细内容可见 [反射机制](反射机制.html#操作运行时类的内部属性及方法)**

```java
public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
    String s = "abc";                                              // 测试字符串对象
    Class<String> stringClass = String.class;                      // 获取 String 类型对象
    Field valueField = stringClass.getDeclaredField("value");      // 获取类型的 value 字段
    valueField.setAccessible(true);                                // 禁止访问安全检查
    char[] value = (char[]) valueField.get(s);                     // 获取 s 的 value 字段
    value[0] = 'A';                                                // 修改第 0 个字符
    System.out.println(s);                                         // 输出结果为 Abc
}
```

