# 浅浅记录一次百度伪笔试「2022-09-13」

### <font color=#1FA774>T1</font>

#### <font color=#9933FF>题目描述</font>

小红拿到了一个字符串，她想知道有多少个"baidu"型子串？
所谓"baidu“型字符串，指第1个、第4个字母是辅音，第2、3、5个字符是元音，且每个字母都不相同的字符串。
例如，"taigu"、"huida"、"paobu"、"baoli"等都是"baidu"型字符串。
我们定义元音字母仅有'a、'e'、'i'、'o'、'u'这五种，其余字母均为辅音字母。

输入一个字符串，长度<=2e5
输出"baidu"型子串的数量

input:
baiduxiaojiabankanjiaran

output:
1

"baidu"和"duoxi"合法。其中"jiaba"和"jiara"不合法，因为a出现了2次。

#### <font color=#9933FF>分析</font>

滑动窗口模版题，详情可见 **[滑动窗口](./滑动窗口.html)**

#### <font color=#9933FF>代码</font>

```java
public int subString(String s) {
    Set<Character> set = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));
    Map<Character, Integer> window = new HashMap<>();
    int l = 0, r = 0, ans = 0;
    while (r < s.length()) {
        char c = s.charAt(r++);
        // 计数
        window.put(c, window.getOrDefault(c, 0) + 1);
        // 有重复的字母
        while (window.get(c) > 1) {
            char d = s.charAt(l++);
            window.put(d, window.get(d) - 1);
        }
        if (r - l == 5) {
            // 判断是否符合要求
            if (!set.contains(s.charAt(l))
                && !set.contains(s.charAt(l + 3))
                && set.contains(s.charAt(l + 1))
                && set.contains(s.charAt(l + 2))
                && set.contains(s.charAt(l + 4))) {
                ans++;
            }
            // 窗口向前移动一格
            char d = s.charAt(l++);
            window.put(d, window.get(d) - 1);
        }
    }
    return ans;
}
```

### <font color=#1FA774>T2</font>

#### <font color=#9933FF>题目描述</font>

有n个怪物排成一排，第i个怪物的血量为ai。小红有两个技能可以打怪：
1. 强力攻击，消耗1mp，对一只怪物造成1点伤害。
2. 踏前斩，消耗5mp，对当前怪物造成1的伤害，同时剑气将波及后两个怪物，对下一个怪物造成2点伤害，对下下个怪物造成3点伤害。

如果一个怪物受伤后血量小于等于0，则怪物死亡。死亡后怪物的尸体依然占据一个位置，会被踏前斩的剑气打到。
小红想知道，击杀全部怪物至少需要花费多少mp？

输入一个n和n个数字作为所有怪物血量
输出最小使用的mp

input:
5
1 2 4 2 3

output:
10

#### <font color=#9933FF>分析</font>

这个题目虽然不是很难，但是有坑 😭😭

当使用「强力攻击」，1mp 对应 1点伤害

当使用「踏前斩」，最好的效果是 5mp 对应 6 点伤害

所以我们的策略就是能使用「踏前斩」，就使用它，它会让我们的攻击收益最高

一开始，我是从左向右贪心，但是貌似有点问题，对于样例「1 2 5 10 15」，从左向右贪心的结果是 30，自己可以手动模拟一波，但如果我们从右向左贪心，结果是 28

我看大家说后台的数据都是从右向左贪心才能得到最优解，如果把上述样例反转「15 10 5 2 1」，那就要从左向右贪心才可以得到最优解

所以这个题目最严谨的做法就是分别「从左向右贪心」和「从右向左贪心」，然后取最小值！

#### <font color=#9933FF>代码</font>

```java
public int master(int[] nums) {
    int n = nums.length;
    if (n <= 2) {
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += nums[i];
        }
        return ans;
    }
    // 正向
    int leftAns = 0;
    int[] temp = Arrays.copyOf(nums, n);
    for (int i = 2; i < n; i++) {
        int t = Math.min(temp[i - 2], Math.min(temp[i - 1] / 2, temp[i] / 3));
        temp[i - 2] -= t;
        temp[i - 1] -= t * 2;
        temp[i] -= t * 3;
        leftAns += 5 * t;
    }
    leftAns += Arrays.stream(temp).sum();
    // 反向
    int rightAns = 0;
    for (int i = n - 3; i >= 0; i--) {
        int t = Math.min(nums[i], Math.min(nums[i + 1] / 2, nums[i + 2] / 3));
        nums[i] -= t;
        nums[i + 1] -= t * 2;
        nums[i + 2] -= t * 3;
        rightAns += 5 * t;
    }
    rightAns += Arrays.stream(nums).sum();
    return Math.min(leftAns, rightAns);
}
```

### <font color=#1FA774>T3</font>

#### <font color=#9933FF>题目描述</font>

小红拿到了一段java代码，请你判断其中最多有多少层for循环嵌套。
保证代码合法，且不含注释。循环语句只有for，条件语句只有if，循环语句和条件语句保证包含大括号用来控制范围。
代码中只有一个类和一个主函数。

多行输入
输出最大嵌套数

input：
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int a = 0 , b = 0;
        int n = in.nextInt();
        for (int i = 0; i < n; i++) {
            if ( a < b ) {
                a += b / 2;
            }
            for (int j = 0; j < n; j++) {
                b++;
                a += b;
            }
            for (int j = 1; j < n; j *= 2) {
                b--;
            }
        }
        System.out.println(a);
    }
}

output:
2

#### <font color=#9933FF>代码</font>

```java
public int forNum(String[] s) {
    Deque<Integer> stack = new ArrayDeque<>();
    StringBuffer sb = new StringBuffer();
    for (String cur : s) sb.append(cur);
    String str = sb.toString();
    int pf = 0; // 1 表示 for 后面的 {；0 表示其他的 {
    int ans = 0, cnt = 0;
    for (int i = 0; i < str.length() - 3; i++) {
        char c = str.charAt(i);
        if (c == '{') {
            stack.addLast(pf);
            cnt += pf;
            pf = 0;
        } else if (c == 'f' && str.charAt(i + 1) == 'o' && str.charAt(i + 2) == 'r') {
            pf = 1;
            i += 2;
        } else if (c == '}') {
            cnt -= stack.removeLast();
        }
        ans = Math.max(ans, cnt);
    }
    return ans;
}
// test
public static void main(String[] args) {
    String[] s = new String[]{
        "import java.util.*;",
        "public class Main{",
        "    public static void main(String[] args){",
        "        Scanner in = new Scanner(System.in);",
        "        int a = 0 , b = 0;",
        "        int n = in.nextInt();",
        "        for (int i = 0; i < n; i++) {",
        "            if ( a < b ) {",
        "                a += b / 2;",
        "            }",
        "            for (int j = 0; j < n; j++) {",
        "                b++;",
        "                a += b;",
        "                for (int k = 0; k < n; k++) {",
        "                }",
        "            }",
        "            for (int j = 1; j < n; j *= 2) {",
        "                b--;",
        "            }",
        "        }",
        "        System.out.println(a);",
        "    }",
        "}"
    };
    ForNum forNum = new ForNum();
    int r = forNum.forNum(s);
    System.out.println(r);
}
```

