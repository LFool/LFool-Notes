# äºŒå‰æ ‘è·¯å¾„ç›¸å…³æŠ€å·§

[112. è·¯å¾„æ€»å’Œ](https://leetcode-cn.com/problems/path-sum/)

[113. è·¯å¾„æ€»å’Œ II](https://leetcode-cn.com/problems/path-sum-ii/)

[437. è·¯å¾„æ€»å’Œ III](https://leetcode-cn.com/problems/path-sum-iii/)

[988. ä»å¶ç»“ç‚¹å¼€å§‹çš„æœ€å°å­—ç¬¦ä¸²](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/)

[543. äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

[687. æœ€é•¿åŒå€¼è·¯å¾„](https://leetcode-cn.com/problems/longest-univalue-path/)

[124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

[1372. äºŒå‰æ ‘ä¸­çš„æœ€é•¿äº¤é”™è·¯å¾„](https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/)

[1367. äºŒå‰æ ‘ä¸­çš„åˆ—è¡¨](https://leetcode-cn.com/problems/linked-list-in-binary-tree/)



OMG OMG OMG OMGï¼ï¼ï¼è‡ªé—­äº†ï¼Œåˆé‡åˆ°äº†ä¸€ä¸ªå¾ˆçƒ¦å¾ˆçƒ¦å¾ˆçƒ¦ç±»å‹çš„é¢˜ç›®

å¯ä»¥å…ˆå»çœ‹æ–‡ç«  **[äºŒå‰æ ‘--çº²é¢†ç¯‡](./äºŒå‰æ ‘--çº²é¢†ç¯‡.html)**ï¼Œç†Ÿæ‚‰äºŒå‰æ ‘çš„æ ¸å¿ƒè¦ä¹‰ï¼å‰æ–‡ä»‹ç»è¿‡æ ‘ç›¸å…³é¢˜ç›®æ‰€ç”¨åˆ°çš„æ–¹æ³•æ— éä¸¤ç§ã€Œåˆ†è§£å­é—®é¢˜ã€&&ã€Œéå†ã€ï¼Œ**è¯¦æƒ…å¯è§ [äºŒå‰æ ‘ã€Œéå†ã€Andã€Œåˆ†è§£ã€](./äºŒå‰æ ‘-éå†-åˆ†è§£.html)**

åŒæ—¶ä¹Ÿå¯ä»¥å»çœ‹çœ‹æœ¬äººæ€»ç»“çš„ä¸€ç¯‡å…³äºäºŒå‰æœç´¢æ ‘ç»å…¸é¢˜ç›®çš„æ–‡ç« ï¼Œé‡Œé¢è¯¦ç»†çš„åˆ†æäº†ç”¨é€’å½’è§£å†³é—®é¢˜æ—¶éœ€è¦æ˜ç¡®çš„è¦ç´ ï¼Œ**è¯¦æƒ…å¯è§ [äºŒå‰æœç´¢æ ‘(BST)](./BST.html)**

æ¥ä¸‹æ¥å…ˆæ¢³ç†ä¸€ä¸‹è·¯å¾„ç›¸å…³é¢˜ç›®çš„å½¢å¼

- å¿…é¡»ç»è¿‡æ ¹èŠ‚ç‚¹ï¼Œä¸”å¿…é¡»åˆ°å¶å­èŠ‚ç‚¹ç»“æŸã€Œ**[112. è·¯å¾„æ€»å’Œ](https://leetcode-cn.com/problems/path-sum/)**ã€ã€Œ**[113. è·¯å¾„æ€»å’Œ II](https://leetcode-cn.com/problems/path-sum-ii/)**ã€ã€Œ**[988. ä»å¶ç»“ç‚¹å¼€å§‹çš„æœ€å°å­—ç¬¦ä¸²](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/)**ã€
- ä¸ç”¨ç»è¿‡æ ¹èŠ‚ç‚¹ï¼Œä½†å¿…é¡»åˆ°å¶å­èŠ‚ç‚¹ç»“æŸã€Œ**[543. äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode-cn.com/problems/diameter-of-binary-tree/)**ã€
- ä¸ç”¨ç»è¿‡æ ¹èŠ‚ç‚¹ï¼Œä¹Ÿä¸ç”¨åˆ°å¶å­èŠ‚ç‚¹ç»“æŸã€Œ**[437. è·¯å¾„æ€»å’Œ III](https://leetcode-cn.com/problems/path-sum-iii/)**ã€ã€Œ**[124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)**ã€ã€Œ**[687. æœ€é•¿åŒå€¼è·¯å¾„](https://leetcode-cn.com/problems/longest-univalue-path/)**ã€ã€Œ**[1372. äºŒå‰æ ‘ä¸­çš„æœ€é•¿äº¤é”™è·¯å¾„](https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/)**ã€ã€Œ**[1367. äºŒå‰æ ‘ä¸­çš„åˆ—è¡¨](https://leetcode-cn.com/problems/linked-list-in-binary-tree/)**ã€

### <font color=#1FA774>è·¯å¾„æ€»å’Œ</font>

**è¯¦æƒ…å¯è§é¢˜ç›® [è·¯å¾„æ€»å’Œ](https://leetcode-cn.com/problems/path-sum/)**

è¿™ä¸ªé¢˜ç›®å¾ˆç®€å•ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œç›´æ¥çœ‹ä»£ç 

```java
// åˆ†è§£å­é—®é¢˜
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) return false;
    if (root.left == null && root.right == null && root.val == targetSum) return true;
    return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
}
```

### <font color=#1FA774>è·¯å¾„æ€»å’Œ II</font>

**è¯¦æƒ…å¯è§é¢˜ç›® [è·¯å¾„æ€»å’Œ II](https://leetcode-cn.com/problems/path-sum-ii/)**

è¿™ä¸ªé¢˜ç›®æœ‰ç‚¹æ„æ€ï¼Œã€Œåˆ†è§£å­é—®é¢˜ && éå†ã€éƒ½å¯ä»¥å†™å‡ºæ¥ï¼Œåªä¸è¿‡ä¸¤ä¸ªæ–¹æ³•çš„éº»çƒ¦ç¨‹åº¦ç®€ç›´ä¸èƒ½æ¯”ï¼ï¼ï¼

æœ¬é¢˜å’Œè¿™ä¸ªé‡Œé¢çš„ã€ŒäºŒå‰æ ‘æ‰€æœ‰è·¯å¾„ã€å¾ˆåƒï¼Œå¯ä»¥å‚è€ƒ [ä¼ é€é—¨](./è®°å½•è‡ªå·±å‚»é€¼æ—¶åˆ».html)

```java
// éå†
// ä¸€èˆ¬éå†éƒ½éœ€è¦å€ŸåŠ©å…¨å±€å˜é‡
private List<List<Integer>> res = new ArrayList<>();
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    traversal(root, targetSum, new ArrayList<Integer>());
    return res;
}
private void traversal(TreeNode root, int targetSum, List<Integer> list) {
    if (root == null) return ;
    list.add(root.val);
    if (root.left == null && root.right == null && root.val == targetSum) {
        res.add(new ArrayList<>(list));
    }
    traversal(root.left, targetSum - root.val, list);
    traversal(root.right, targetSum - root.val, list);
    list.remove(list.size() - 1);
}

// åˆ†è§£å­é—®é¢˜
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;
    List<Integer> list = new ArrayList<>();
    list.add(root.val);
    if (root.left == null && root.right == null && root.val == targetSum) {
        res.add(new ArrayList<>(list));
        return res;
    }
    List<List<Integer>> leftRes = pathSum(root.left, targetSum - root.val);
    List<List<Integer>> rightRes = pathSum(root.right, targetSum - root.val);
    if (leftRes.size() != 0) {
        for (List<Integer> left : leftRes) {
            List<Integer> cur = new ArrayList<>(list);
            cur.addAll(left);
            res.add(cur);
        }
    }
    if (rightRes.size() != 0) {
        for (List<Integer> right : rightRes) {
            List<Integer> cur = new ArrayList<>(list);
            cur.addAll(right);
            res.add(cur);
        }
    }
    return res;
}
```

### <font color=#1FA774>è·¯å¾„æ€»å’Œ III</font>

**è¯¦æƒ…å¯è§é¢˜ç›® [è·¯å¾„æ€»å’Œ III](https://leetcode-cn.com/problems/path-sum-iii/)**

è¿™ä¸ªé¢˜ç›®éœ€è¦ç”¨åˆ°ã€Œå‰ç¼€å’Œã€çš„æ€æƒ³ï¼Œ**è¯¦æƒ…å¯è§ [å‰ç¼€å’ŒæŠ€å·§](./å‰ç¼€å’Œæ•°ç»„.html)**

```java
private Map<Integer, Integer> preSumCount = new HashMap<>();
private int pathSum;
private int targetSum;
private int res;
public int pathSum(TreeNode root, int targetSum) {
    if (root == null) return 0;
    this.pathSum = 0;
    this.targetSum = targetSum;
    this.res = 0;
    // base case
    preSumCount.put(0, 1);
    traversal(root);
    return res;
}
private void traversal(TreeNode root) {
    if (root == null) return ;
    // å…ˆåºä½ç½®ï¼šé¦–æ¬¡è¿›å…¥æ—¶æ‰§è¡Œ
    pathSum += root.val;
    res += preSumCount.getOrDefault(pathSum - targetSum, 0);
    preSumCount.put(pathSum, preSumCount.getOrDefault(pathSum, 0) + 1);

    traversal(root.left);
    traversal(root.right);
    // ååºä½ç½®ï¼šå³å°†ç¦»å¼€æ—¶çš„æ‰§è¡Œ
    preSumCount.put(pathSum, preSumCount.get(pathSum) - 1);
    pathSum -= root.val;
}
```

### <font color=#1FA774>ä»å¶ç»“ç‚¹å¼€å§‹çš„æœ€å°å­—ç¬¦ä¸²</font>

**è¯¦æƒ…å¯è§é¢˜ç›® [ä»å¶ç»“ç‚¹å¼€å§‹çš„æœ€å°å­—ç¬¦ä¸²](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/)**

å…¶å®è¿™ä¸ªé¢˜ç›®å°±æ˜¯éå†å‡ºæ‰€æœ‰è·¯å¾„ï¼Œç„¶åæ¯”è¾ƒè·¯å¾„çš„å¤§å°

åªä¸è¿‡æ¯”è¾ƒçš„æ—¶å€™æœ‰ç‚¹éº»çƒ¦ï¼Œæ¶‰åŠåˆ°äº†å­—ç¬¦ä¸²çš„æ¯”è¾ƒ

```java
// éå†
// å€ŸåŠ©å…¨å±€éå†
// å­˜æ”¾ç»“æœ
private String res = new String();
// ä¸­é—´è·¯å¾„
private StringBuffer sb = new StringBuffer();
public String smallestFromLeaf(TreeNode root) {
    traversal(root);
    return res;
}
private void traversal(TreeNode root) {
    if (root == null) return ;
    // è¿›å…¥æ—¶åŠ å…¥å½“å‰å…ƒç´ 
    sb.append((char) (root.val + 'a'));
    // åˆ¤æ–­æ˜¯å¦ä¸ºå¶å­èŠ‚ç‚¹
    if (root.left == null && root.right == null) {
        // æ¯”è¾ƒè¿‡ç¨‹
        String s = new StringBuffer(sb).reverse().toString();
        if ("".equals(res)) res = s;
        res = s.compareTo(res) <= 0 ? s : res;
    }
    traversal(root.left);
    traversal(root.right);
    // ç¦»å¼€æ—¶ç§»é™¤å½“å‰å…ƒç´ 
    sb.setLength(sb.length() - 1);
}
```

### <font color=#1FA774>äºŒå‰æ ‘çš„ç›´å¾„</font>

**è¯¦æƒ…å¯è§é¢˜ç›® [äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode-cn.com/problems/diameter-of-binary-tree/)**

**<font color='red'>æ€è·¯ï¼š</font>**åˆ†è§£å­é—®é¢˜ï¼Œå½“å‰èŠ‚ç‚¹çš„ç›´å¾„å’Œ = å·¦å­æ ‘çš„é«˜åº¦ + å³å­æ ‘çš„é«˜åº¦

**<font color='red'>æŠ€å·§ï¼š</font>**åˆ©ç”¨ååºéå†ï¼Œåˆšå¥½å¯ä»¥ä¸€è¾¹æ±‚é«˜åº¦ï¼Œä¸€è¾¹å–æœ€å€¼ï¼›ä¸ç„¶å°±éœ€è¦ä¸€æ¬¡æ¬¡çš„é‡å¤æ±‚å¥½å¤šæ¬¡é«˜åº¦

âš ï¸ åŒºåˆ†æ¸…æ¥š **é«˜åº¦ && æ·±åº¦**

```java
private int res = 0;
public int diameterOfBinaryTree(TreeNode root) {
    diameterOfBinaryTreeHelper(root);
    return res;
}
private int diameterOfBinaryTreeHelper(TreeNode root) {
    if (root == null) return 0;
    int lh = diameterOfBinaryTreeHelper(root.left);
    int rh = diameterOfBinaryTreeHelper(root.right);
    // ååºéå†å¤„ç†é˜¶æ®µ
    // æ›´æ–°æœ€å€¼
    res = Math.max(res, lh + rh);
    // è¿”å›å½“å‰å­æ ‘é«˜åº¦
    return Math.max(lh, rh) + 1;
}
```

### <font color=#1FA774>äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ</font>

**è¯¦æƒ…å¯è§é¢˜ç›® [äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)**

è¿™ä¸ªé¢˜ç›®éš¾åº¦æ˜¯ `hard`ï¼Œçœ‹èµ·æ¥å“ä¸€è·³ï¼Œä½†æ˜¯æœ¬äººä¸€å¼€å§‹çæ‘¸ç´¢ï¼Œå±…ç„¶å†™å‡ºæ¥äº†ï¼Œä½†æ˜¯æ²¡æœ‰å…¶ä»–äººçš„è§£æ³•å¦™

```java
// æœ¬äººè§£æ³• ğŸ˜­
private int res = Integer.MIN_VALUE;
public int maxPathSum(TreeNode root) {
    maxPathSumHelper(root);
    return res;
}
private int maxPathSumHelper(TreeNode root) {
    if (root == null) return 0;
    int leftMax = maxPathSumHelper(root.left);
    int rightMax = maxPathSumHelper(root.right);
    
    // ä¸»è¦åˆ©ç”¨ä¸‹é¢å››è¡Œä»£ç è¿›è¡Œäº†è´Ÿå€¼çš„èˆå¼ƒ
    // åˆ†åˆ«å’ŒåŠ ä¸Šå·¦å³ï¼ŒåªåŠ å·¦æˆ–å³ï¼Œåªæœ‰æ ¹ è¿›è¡Œæœ€å¤§å€¼å–èˆ
    // å…¶å®æ•ˆæœå’Œä¸‹é¢ä¸ 0 è¿›è¡Œæ¯”è¾ƒä¸€æ ·
    res = Math.max(res, leftMax + rightMax + root.val);
    res = Math.max(res, leftMax + root.val);
    res = Math.max(res, rightMax + root.val);
    res = Math.max(res, root.val);

    // è¿”å›å€¼ä¹Ÿåªè¦å’Œæ ¹å•ç‹¬è¿›è¡Œä¸€ä¸ªæ¯”è¾ƒ
    return Math.max(Math.max(leftMax, rightMax) + root.val, root.val);
}

// ä¼˜è´¨è§£æ³•
private int res = Integer.MIN_VALUE;
public int maxPathSum(TreeNode root) {
    maxPathSumHelper(root);
    return res;
}
private int maxPathSumHelper(TreeNode root) {
    if (root == null) return 0;
    // æ ¸å¿ƒåœ°æ–¹ï¼šå’Œ 0 åšä¸€ä¸ªå–èˆ
    // å¦‚æœæ˜¯è´Ÿå€¼ï¼Œåˆ™èˆå¼ƒ
    // è¿™æ ·å°±å¯ä»¥ä¸éœ€è¦ä»å¶å­èŠ‚ç‚¹å¼€å§‹åˆ°å¶å­èŠ‚ç‚¹ç»“æŸ
    int leftMax = Math.max(0, maxPathSumHelper(root.left));
    int rightMax = Math.max(0, maxPathSumHelper(root.right));

    res = Math.max(res, leftMax + rightMax + root.val);

    return Math.max(leftMax, rightMax) + root.val;
}
```
çªç„¶çœ‹åˆ°äº†ä¸€ç¯‡é¢ç»ï¼Œæœ‰çš„é¢è¯•å®˜éœ€è¦è®©ä½ è¾“å‡ºæœ€é•¿å’Œçš„è·¯å¾„ï¼Œä¸‹é¢æ¥å®ç°ä¸€ä¸‹ï¼š

```java
class Solution {
    // å­˜å‚¨ç»“æœ
    // ä¸€å¼€å§‹è·¯å¾„å’Œéœ€è¦åˆå§‹ä¸ºæœ€å°å€¼
    private Pair ans = new Pair(Integer.MIN_VALUE, new ArrayList<>());
    public int maxPathSum(TreeNode root) {
        maxPathSumHelper(root);
        return ans.sum;
    }

    private Pair maxPathSumHelper(TreeNode root) {
        Pair res = new Pair(0, new ArrayList<>());
        if (root == null) return res;
        Pair leftRes = maxPathSumHelper(root.left);
        Pair rightRes = maxPathSumHelper(root.right);
        // èˆå»è·¯å¾„å’Œä¸ºè´Ÿæ•°çš„å­©å­
        if (leftRes.sum <= 0) leftRes = new Pair(0, new ArrayList<>());
        if (rightRes.sum <= 0) rightRes = new Pair(0, new ArrayList<>());
        // è®°å½•å½“å‰è·¯å¾„å’Œï¼Œå³ï¼šå·¦å­©å­ æ ¹ å³å­©å­
        int curSum = root.val + leftRes.sum + rightRes.sum;
        // æ›´æ–°æœ€é•¿è·¯å¾„å’Œ
        if (ans.sum < curSum) {
            List<Integer> curPath = new ArrayList<>();
            curPath.addAll(leftRes.path);
            curPath.add(root.val);
            curPath.addAll(rightRes.path);
            ans = new Pair(curSum, curPath);
        }
        // å¤„ç†è¿”å›å€¼
        // ä»å·¦å³å­©å­ä¸­é€‰æ‹©ä¸€æ¡æ›´é•¿çš„è·¯
        if (leftRes.sum >= rightRes.sum) {
            res.path.addAll(leftRes.path);
            res.path.add(root.val);
            res.sum = root.val + leftRes.sum;
        } else {
            res.path.add(root.val);
            res.path.addAll(rightRes.path);
            res.sum = root.val + rightRes.sum;
        }
        return res;
    }
}
class Pair {
    // å­˜å‚¨è·¯å¾„å’Œ
    int sum;
    // å­˜å‚¨è·¯å¾„
    List<Integer> path;
    public Pair(int sum, List<Integer> path) {
        this.sum = sum;
        this.path = path;
    }
}
```

### <font color=#1FA774>æœ€é•¿åŒå€¼è·¯å¾„</font>

**è¯¦æƒ…å¯è§é¢˜ç›® [æœ€é•¿åŒå€¼è·¯å¾„](https://leetcode-cn.com/problems/longest-univalue-path/)**

å½“æ—¶ä¸€ç…ï¼Œä¸çŸ¥é“ä½•ä»ä¸‹æ‰‹ï¼›ç›´åˆ°çœ‹åˆ°äº†ä¸€å¥æé†’ï¼Œæœ‰äº†å¯å‘ `è¿”å›å’Œå½“å‰èŠ‚ç‚¹å€¼ç›¸åŒçš„æœ€å¤§é«˜åº¦` è¯´ç™½äº†å°±æ˜¯ææ¸…æ¥šé€’å½’ä¸‰è¦ç´ ä¸­è¿”å›å€¼çš„å«ä¹‰

```java
// è®°å½•æœ€ç»ˆç»“æœ
private int res = 0;
public int longestUnivaluePath(TreeNode root) {
    longestUnivaluePathHelper(root);
    return res;
}
private int longestUnivaluePathHelper(TreeNode root) {
    if (root == null) return 0;
    int left = longestUnivaluePathHelper(root.left);
    int right = longestUnivaluePathHelper(root.right);
    // ååºéå†å¤„ç†é˜¶æ®µ
    // maxLenï¼šè®°å½•å½“å‰è·¯å¾„é•¿åº¦
    int maxLen = 0;
    // maxSameDepthï¼šè®°å½•å½“å‰æœ€å¤§é«˜åº¦
    int maxSameDepth = 0;
    // å¦‚æœå·¦å­©å­ä¸ä¸ºç©ºï¼Œä¸”å€¼ç›¸åŒ
    if (root.left != null && root.val == root.left.val) {
        // maxLen åŠ ä¸Šå·¦å­©å­è·¯å¾„
        maxLen += (left + 1);
        // æ›´æ–°æœ€å¤§é«˜åº¦
        maxSameDepth = Math.max(maxSameDepth, left + 1);
    }
    if (root.right != null && root.val == root.right.val) {
        // maxLen åŠ ä¸Šå³å­©å­è·¯å¾„
        maxLen += (right + 1);
        // æ›´æ–°æœ€å¤§é«˜åº¦
        maxSameDepth = Math.max(maxSameDepth, right + 1);
    }
    // æ›´æ–°æœ€ç»ˆç»“æœ
    res = Math.max(res, maxLen);
    return maxSameDepth; 
}
```

æ˜¯ä¸æ˜¯æ„Ÿè§‰ä¸€ä¸‹æŠŠæ­£ç¡®ä»£ç ç»™å‡ºï¼Œçœ‹ä¼¼å¤ªç®€å•äº†

ç›´æ¥ä¸Šå‡ ä¸ªæœ¬äººè‡ªé—­æ—¶å€™çš„é”™è¯¯ç‰ˆæœ¬ï¼ˆæ ¸å¿ƒä»£ç éƒ¨åˆ†ï¼‰

```java
// é”™è¯¯ç‰ˆæœ¬ 1
int maxLen = 0;
if (root.left != null && root.val == root.left.val) maxLen += (left + 1);
if (root.right != null && root.val == root.right.val) maxLen += (right + 1);
res = Math.max(res, maxLen);
// é”™è¯¯ç‚¹ï¼šç›´æ¥è¿”å›äº†è·¯å¾„çš„é•¿åº¦ï¼Œä¼šå¯¼è‡´ç»“æœ å¤§äº æ­£ç¡®ç»“æœ
// æ­£ç¡®æ€è·¯ï¼šè¿”å›å’Œå½“å‰èŠ‚ç‚¹å€¼ç›¸åŒçš„æœ€å¤§é«˜åº¦
return curRes; 

// --------------- åˆ†éš”çº¿ ---------------

// é”™è¯¯ç‰ˆæœ¬ 2
// ååºéå†å¤„ç†é˜¶æ®µ
int maxLen = 0;
if (root.left != null && root.val == root.left.val) maxLen += (left + 1);
if (root.right != null && root.val == root.right.val) maxLen += (right + 1);
res = Math.max(res, maxLen);
// é”™è¯¯ç‚¹ï¼šæ²¡æœ‰è€ƒè™‘å€¼ç›¸åŒè¿™ä¸ªå› ç´ ï¼Œå€¼ä¸åŒçš„æ—¶å€™ï¼Œä¹Ÿä¼šè¿”å› +1 çš„ç»“æœï¼Œä¼šå¯¼è‡´é”™è¯¯
// æ­£ç¡®æ€è·¯ï¼šåªæœ‰å½“å€¼ç›¸åŒçš„æ—¶å€™ï¼Œæ‰è¿”å›ï¼›å€¼ä¸åŒçš„æ—¶å€™åº”è¯¥è¿”å› 0
return Math.max(left, right) + 1;
```

### <font color=#1FA774>äºŒå‰æ ‘ä¸­çš„æœ€é•¿äº¤é”™è·¯å¾„</font>

**è¯¦æƒ…å¯è§é¢˜ç›® [äºŒå‰æ ‘ä¸­çš„æœ€é•¿äº¤é”™è·¯å¾„](https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/)**

è¿™ä¸ªé¢˜ç›®å¾ˆæœ‰æ„æ€ï¼Œæœ¬äººä¸€å¼€å§‹æƒ³åˆ°çš„å°±æ˜¯åˆ†è§£å­é—®é¢˜ï¼Œç»“æœæŠŠè‡ªå·±ç»•æ¥ç»•å» ç»•æ™•äº† ğŸ˜­ğŸ˜­ğŸ˜­

ä¸‹é¢æ˜¯åˆ†è§£çš„è§£æ³•ï¼Œå¯æƒœè¶…æ—¶ ğŸ˜­ğŸ˜­ğŸ˜­

ä¸è¿‡å¯ä»¥ä½“ä¼šä¸€ä¸‹è¿™ç§æ€æƒ³ï¼Œå³ï¼šæœ€ä¼˜è§£å¯èƒ½ä¸åœ¨å½“å‰èŠ‚ç‚¹

```java
private int res = 0;
public int longestZigZag(TreeNode root) {
    helper(root);
    return res;
}
// å¯¹äºå½“å‰èŠ‚ç‚¹ï¼Œæœ€ä¼˜è§£å¯èƒ½å‡ºç°åœ¨è¯¥èŠ‚ç‚¹å‘å·¦å­©å­è¿›è¡Œæœç´¢ï¼Œä¹Ÿå¯èƒ½å‡ºç°åœ¨è¯¥èŠ‚ç‚¹å‘å³å­©å­è¿›è¡Œæœç´¢
// åŒæ—¶ï¼Œä¹Ÿå¯èƒ½æœ€ä¼˜è§£ä¸åœ¨å½“å‰èŠ‚ç‚¹ï¼Œè€Œåœ¨å·¦å³èŠ‚ç‚¹ä¸­
private void helper(TreeNode root) {
    if (root == null) return ;
    // å¯¹äºæœ€ä¼˜è§£å°±åœ¨å½“å‰èŠ‚ç‚¹ä¸Šæ—¶
    res = Math.max(res, Math.max(searchZigZag(root, 0), searchZigZag(root, 1)));
    // å¦‚æœä¸åœ¨ï¼Œåˆ™ç»§ç»­æœç´¢å·¦å³èŠ‚ç‚¹
    helper(root.left);
    helper(root.right);
}
// ç»™å®šæ–¹å‘ï¼Œè¿›è¡Œæœç´¢
private int searchZigZag(TreeNode root, int dir) {
    if (root == null) return -1;

    if (dir == 0) return searchZigZag(root.left, 1) + 1;
    else return searchZigZag(root.right, 0) + 1;
}
```

ä¸‹é¢æ˜¯è¿›è¡Œäº†ä¼˜åŒ–çš„è§£æ³•ï¼Œè¯¥è§£æ³•å¾ˆå·§å¦™ã€‚åˆ©ç”¨ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„ç¬¬ä¸€ä¸ªæ•°è¡¨ç¤ºå½“å‰èŠ‚ç‚¹å‘å·¦æœç´¢çš„ç»“æœï¼Œæ•°ç»„çš„ç¬¬äºŒä¸ªæ•°è¡¨ç¤ºå½“å‰èŠ‚ç‚¹å‘å³æœç´¢çš„ç»“æœ

```java
private int res = 0;
public int longestZigZag(TreeNode root) {
    getPathSum(root);
    return res;
}
private int[] getPathSum(TreeNode root) {
    // å¦‚æœä¸ºç©º -1 (æ­¤å¤„ä¹Ÿå¾ˆå¦™)
    // å¦‚æœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œåˆ™å¯ä»¥ +1 å˜æˆ 0
    // å¦‚æœæ˜¯ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œåˆ™ç»§ç»­ +1 å˜æˆ 1
    // åˆšå¥½æ»¡è¶³èŠ‚ç‚¹æ•°é‡å’Œè¾¹ä¹‹é—´çš„å…³ç³» å¦™å‘€ï½ï½ï½
    if (root == null) return new int[]{-1, -1};
    int[] left = getPathSum(root.left);
    int[] right = getPathSum(root.right);
    // ååºéå†æ—¶å¤„ç† (å‘ç°å¾ˆå¤šé¢˜ç›®éƒ½å€ŸåŠ©äº†ååºéå†çš„ç‰¹ç‚¹)
    // æ›´æ–°å€¼ï¼Œæ³¨æ„é€»è¾‘
    int leftPath = left[1] + 1;
    int rightPath = right[0] + 1;
    res = Math.max(res, Math.max(leftPath, rightPath));
    return new int[]{leftPath, rightPath};
}
```

### <font color=#1FA774>äºŒå‰æ ‘ä¸­çš„åˆ—è¡¨</font>

**è¯¦æƒ…å¯è§é¢˜ç›® [äºŒå‰æ ‘ä¸­çš„åˆ—è¡¨](https://leetcode-cn.com/problems/linked-list-in-binary-tree/)**

è¿™ä¸ªé¢˜ç›®ä¹Ÿæ˜¯å˜ç›¸çš„ä¸€ç§å¯»æ‰¾è·¯å¾„ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¬¦åˆçš„è·¯å¾„

è¿™ä¸ªé¢˜ç›®å’Œä¸Šé¢çš„é¢˜ç›®å¾ˆåƒï¼Œå¦‚æœåˆ©ç”¨ã€Œåˆ†è§£å­é—®é¢˜ã€çš„æ€æƒ³å»å†™**æ›´åƒ**

`æ­£ç¡®è§£å¯èƒ½æ˜¯å½“å‰èŠ‚ç‚¹ï¼Œä¹Ÿå¯èƒ½æ˜¯å­©å­èŠ‚ç‚¹å¼€å§‹`

```java
public boolean isSubPath(ListNode head, TreeNode root) {
    if (head == null) return true;
    if (root == null) return false;
    // ä¸‰è€…æ»¡è¶³å…¶ä¸€å°± ğŸ‰‘ï¸
    return isSub(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);
}
private boolean isSub(ListNode head, TreeNode root) {
    if (head == null) return true;
    if (root == null) return false;
    if (root.val != head.val) return false;
    return isSub(head.next, root.left) || isSub(head.next, root.right);
}
```

