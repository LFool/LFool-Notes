# äºŒåˆ†é¢˜ç›®æ¨¡ç‰ˆå¼é¢˜è§£

### <font color=#1FA774>å‰è¨€</font>

å‰æ–‡ **[äºŒåˆ†æœç´¢](./äºŒåˆ†æœç´¢.html)** ä¸­ä»‹ç»äº†äºŒåˆ†æœç´¢çš„åŸç†å’Œæ¨¡ç‰ˆï¼Œä½†æ˜¯æœ¬äººæ„Ÿè§‰å¹¶ä¸æ˜¯å¾ˆå®Œç¾ã€‚å¤§é‡åˆ·é¢˜çš„ç§¯ç´¯ï¼Œå‘ç°äº†ä¸€ä¸ªå¾ˆä¸é”™çš„æ¨¡ç‰ˆï¼Œä¼ é€é—¨ ğŸ‘‰ **[äºŒåˆ†æŸ¥æ‰¾ç®—æ³•æ¨¡æ¿](https://www.acwing.com/blog/content/31/)**

æœ¬ç¯‡æ–‡ç« ä»¥ã€ŒäºŒåˆ†ã€ä¸ºä¸“é¢˜ï¼Œç½—åˆ—äº†é«˜é¢‘é‡è¦çš„ç›¸å…³é¢˜ç›®ï¼Œè€Œä¸”æœ¬æ–‡æ‰€æœ‰é¢˜ç›®çš„ä»£ç æ€è·¯ä¸¥æ ¼ä¿æŒä¸€è‡´ï¼Œä¹Ÿå°±æ˜¯éµå¾ªä¼ é€é—¨ä¸­é€šç”¨çš„ç®—æ³•æ¨¡ç‰ˆï¼ï¼

### <font color=#1FA774>é¢˜ç›®</font>

**[704. äºŒåˆ†æŸ¥æ‰¾](https://leetcode.cn/problems/binary-search/)**

```java
public int search(int[] nums, int target) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int m = l + r >> 1;
        if (nums[m] >= target) r = m;
        else l = m + 1;
    }
    return nums[l] == target ? l : -1;
}
```

**[69. x çš„å¹³æ–¹æ ¹](https://leetcode.cn/problems/sqrtx/)**

```java
public int mySqrt(int x) {
    if (x == 0) return 0;
    int l = 1, r = x;
    while (l < r) {
        int m = l + r + 1 >>> 1;
        if (x / m >= m) l = m;
        else r = m - 1;
    }
    return l;
}
```

**[374. çŒœæ•°å­—å¤§å°](https://leetcode.cn/problems/guess-number-higher-or-lower/)**

```java
public int guessNumber(int n) {
    int l = 1, r = n;
    while (l < r) {
        int m = l + r + 1 >>> 1;
        if (guess(m) >= 0) l = m;
        else r = m - 1;
    }
    return l;
}
```

**[å‰‘æŒ‡ Offer 53 - II. 0ï½n-1ä¸­ç¼ºå¤±çš„æ•°å­—](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)**

```java
public int missingNumber(int[] nums) {
    int l = 0, r = nums.length;
    while (l < r) {
        int m = l + r >>> 1;
        if (nums[m] > m) r = m;
        else l = m + 1;
    }
    return l;
}
```

**[33. æœç´¢æ—‹è½¬æ’åºæ•°ç»„](https://leetcode.cn/problems/search-in-rotated-sorted-array/)**

```java
public int search(int[] nums, int target) {
    int n = nums.length;
    int l = 0, r = n - 1;
    while (l < r) {
        int m = l + r + 1 >> 1;
        if (nums[m] <= nums[r]) {
            if (nums[m] <= target && target <= nums[r]) l = m;
            else r = m - 1;
        } else {
            if (nums[l] <= target && target <= nums[m]) r = m;
            else l = m + 1;
        }
    }
    return nums[l] == target ? l : -1;
}
```

**[153. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)**

```java
public int findMin(int[] nums) {
    int n = nums.length;
    int l = 0, r = n - 1;
    while (l < r) {
        int m = l + r >> 1;
        if (nums[m] <= nums[r]) r = m;
        else l = m + 1;
    }
    return nums[l];
}
```

**[154. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)**

```java
public int findMin(int[] nums) {
    int n = nums.length;
    int l = 0, r = n - 1;
    while (l < r) {
        int m = l + r >> 1;
        if (nums[m] == nums[r]) r--;
        else if (nums[m] < nums[r]) r = m;
        else l = m + 1;
    }
    return nums[l];
}
```

**[81. æœç´¢æ—‹è½¬æ’åºæ•°ç»„ II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)**

```java
public boolean search(int[] nums, int target) {
    int n = nums.length;
    int l = 0, r = n - 1;
    while (l < r) {
        int m = l + r + 1 >> 1;
        if (nums[m] == target) return true;
        if (nums[m] == nums[r]) r--;
        else if (nums[m] < nums[r]) {
            if (nums[m] <= target && target <= nums[r]) l = m;
            else r = m - 1;
        } else {
            if (nums[l] <= target && target <= nums[m]) r = m;
            else l = m + 1;
        }
    }
    return nums[l] == target;
}
```

**[278. ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬](https://leetcode.cn/problems/first-bad-version/)**

```java
public int firstBadVersion(int n) {
    int l = 1, r = n;
    while (l < r) {
        int m = l + r >>> 1;
        if (isBadVersion(m)) r = m;
        else l = m + 1;
    }
    return l;
}
```

**[162. å¯»æ‰¾å³°å€¼](https://leetcode.cn/problems/find-peak-element/)**

```java
public int findPeakElement(int[] nums) {
    int n = nums.length, l = 0, r = n - 1;
    while (l < r) {
        int m = l + r >> 1;
        if (m + 1 < n && nums[m] > nums[m + 1]) r = m;
        else l = m + 1; 
    }
    return l;
}
```

**[34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)**

```java
public int[] searchRange(int[] nums, int target) {
    int n = nums.length;
    if (n == 0) return new int[]{-1, -1};
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (target <= nums[mid]) r = mid;
        else l = mid + 1;
    }
    int r1 = nums[l] == target ? l : -1;
    l = 0; r = n - 1;
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (target >= nums[mid]) l = mid;
        else r = mid - 1;
    }
    int r2 = nums[l] == target ? l : -1;
    return new int[]{r1, r2};
}
```

**[35. æœç´¢æ’å…¥ä½ç½®](https://leetcode.cn/problems/search-insert-position/)**

```java
public int searchInsert(int[] nums, int target) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (target <= nums[mid]) r = mid;
        else l = mid + 1;
    }
    return nums[l] >= target ? l : l + 1;
}
```

**[74. æœç´¢äºŒç»´çŸ©é˜µ](https://leetcode.cn/problems/search-a-2d-matrix/)**

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length, n = matrix[0].length;
    int l = 0, r = m * n - 1;
    while (l < r) {
        int mid = l + r >> 1;
        int row = mid / n, col = mid % n;
        if (target <= matrix[row][col]) r = mid;
        else l = mid + 1;
    }
    return matrix[l / n][l % n] == target;
}
```

**[658. æ‰¾åˆ° K ä¸ªæœ€æ¥è¿‘çš„å…ƒç´ ](https://leetcode.cn/problems/find-k-closest-elements/)**

```java
public List<Integer> findClosestElements(int[] arr, int k, int x) {
    int n = arr.length;
    int l = 0, r = n - 1;
    while (l < r) {
        int m = l + r >> 1;
        if (arr[m] >= x) r = m;
        else l = m + 1;
    }
    int left = l - 1, right = r + 1;
    if (l > 0 && arr[l] != x) {
        int t = x - arr[l - 1] <= arr[l] - x ? l - 1 : l;
        left = t - 1; right = t + 1;
    }

    while (right - left - 1 < k) {
        if (left >= 0 && right < n) {
            if (x - arr[left] <= arr[right] - x) left--;
            else right++;
        } else if (left >= 0) left--;
        else if (right < n) right++;
    }
    List<Integer> ans = new ArrayList<>();
    for (int i = left + 1; i < right; i++) ans.add(arr[i]);
    return ans;
}
```

**[29. ä¸¤æ•°ç›¸é™¤](https://leetcode.cn/problems/divide-two-integers/)**

```java
public int divide(int dividend, int divisor) {
    if (dividend == 0) return 0;
    if (divisor == 1) return dividend;
    if (divisor == -1) {
        if (dividend == Integer.MIN_VALUE) return Integer.MAX_VALUE;
        return -dividend;
    }
    long a = dividend, b = divisor;
    if ((a > 0 && b > 0) || (a < 0 && b < 0)) return (int) f(Math.abs(a), Math.abs(b));
    return (int) f(Math.abs(a), Math.abs(b)) * -1;
}
private long f(long a, long b) {
    if (a < b) return 0L;
    long res = 1, t = b;
    while (t + t <= a) {
        res += res;
        t += t;
    }
    return res + f(a - t, b);
}
```

**[875. çˆ±åƒé¦™è•‰çš„ç‚ç‚](https://leetcode.cn/problems/koko-eating-bananas/)**

```java
public int minEatingSpeed(int[] piles, int h) {
    int l = 1, r = (int) 1e9;
    while (l < r) {
        int v = l + r >> 1;
        if (check(piles, h, v)) r = v;
        else l = v + 1;
    }
    return l;
}
private boolean check(int[] piles, int h, int v) {
    int cnt = 0;
    for (int x : piles) {
        cnt += (x + v - 1) / v;
    }
    return cnt <= h;
}
```

**[668. ä¹˜æ³•è¡¨ä¸­ç¬¬kå°çš„æ•°](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)**

```java
public int findKthNumber(int m, int n, int k) {
    if (m > n) return findKthNumber(n, m, k);
    int l = 0, r = (int) 1e9;
    while (l < r) {
        int v = l + r >> 1;
        if (check(m, n, k, v)) r = v;
        else l = v + 1;
    }
    return l;
}
private boolean check(int m, int n, int k, int v) {
    int cnt = 0;
    for (int i = 1; i <= m; i++) {
        cnt += Math.min(n, v / i);
    }
    return cnt >= k;
}
```

**[436. å¯»æ‰¾å³åŒºé—´](https://leetcode.cn/problems/find-right-interval/)**

```java
public int[] findRightInterval(int[][] intervals) {
    int n = intervals.length;
    Integer[] idx = IntStream.range(0, n).boxed().toArray(Integer[]::new);
    Arrays.sort(idx, (a, b) -> intervals[a][0] - intervals[b][0]);
    int[] ans = new int[n];
    Arrays.fill(ans, -1);
    for (int i = 0; i < n; i++) {
        int l = i, r = n - 1, target = intervals[idx[i]][1];
        while (l < r) {
            int m = l + r >> 1;
            if (target <= intervals[idx[m]][0]) r = m;
            else l = m + 1;
        }
        if (l < n && target <= intervals[idx[l]][0]) ans[idx[i]] = idx[l];
    }
    return ans;
}
```

**[528. æŒ‰æƒé‡éšæœºé€‰æ‹©](https://leetcode.cn/problems/random-pick-with-weight/)**

```java
class Solution {

    private int n;
    private int[] ps;
    private Random random = new Random();

    public Solution(int[] w) {
        n = w.length;
        ps = new int[n + 1];
        for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + w[i];
    }
    
    public int pickIndex() {
        int target = random.nextInt(ps[n]) + 1;
        int l = 1, r = n;
        while (l < r) {
            int m = l + r >> 1;
            if (ps[m] >= target) r = m;
            else l = m + 1;
        }
        return l - 1;
    }
}
```

**[497. éé‡å çŸ©å½¢ä¸­çš„éšæœºç‚¹](https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/)**

```java
class Solution {

    private int n;
    private int[] ps;
    private int[][] rs;
    private Random random = new Random();

    public Solution(int[][] rects) {
        n = rects.length;
        rs = rects;
        ps = new int[n + 1];
        for (int i = 0; i < n; i++) {
            ps[i + 1] = ps[i] + (rs[i][2] - rs[i][0] + 1) * (rs[i][3] - rs[i][1] + 1);
        }
    }
    
    public int[] pick() {
        int target = random.nextInt(ps[n]) + 1;
        int l = 1, r = n;
        while (l < r) {
            int m = l + r >> 1;
            if (ps[m] >= target) r = m;
            else l = m + 1;
        }
        int x = rs[l - 1][0] + random.nextInt(rs[l - 1][2] - rs[l - 1][0] + 1);
        int y = rs[l - 1][1] + random.nextInt(rs[l - 1][3] - rs[l - 1][1] + 1);
        return new int[]{x, y};
    }
}
```

**[240. æœç´¢äºŒç»´çŸ©é˜µ II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)**

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length, n = matrix[0].length;
    int i = m - 1, j = 0;
    while (i >= 0 && j < n) {
        if (matrix[i][j] == target) return true;
        if (matrix[i][j] < target) j++;
        else i--;
    }
    return false;
}
```

