# TCP/IP 网络模型

### <font color=#1FA774>网络协议</font>

通俗来说，协议可理解为一种标准，它规定了通信双方发送数据的格式、顺序以及响应内容

**<font color='red'>定义：</font>**网络协议定义了两个或多个通信实体之间交换数据的报文格式和顺序，以及报文发送/接收或其它事件所采取的动作

一个网络协议至少包含三要素：

- **语法：**数据与控制信息的结构或格式 -> 格式
- **语义：**需要发出何种控制信息，完成何种动作以及做出何种响应 -> 响应内容
- **同步：**事件实现顺序的详细说明 -> 顺序

### <font color=#1FA774>协议分层</font>

国际标准化组织 (ISO) 提出七层网络模型，包括：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。但这套标准却没有被广泛使用，反而是非国际标准 TCP/IP 使用更广泛

它们俩的区别在于：ISO 中的应用层、表示层、会话层相当于 TCP/IP 中的应用层；ISO 中的数据链路层、物理层相当于 TCP/IP 中的网络接口层，如下图所示

![1](https://cdn.jsdelivr.net/gh/LFool/new-image-hosting@master/20230524/0235521684866952j1lLVF1.svg)

表示层的作用是使通信的应用程序能够解释交换数据的含义；会话层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。之所以 TCP/IP 将这两层合并到应用层是为了将实现交给应用程序的开发者，如果应用程序需要这两层的服务就实现它，如果不需要就不管它

### <font color=#1FA774>TCP/IP 网络模型</font>

进程间通信有很多种方式，对于同一台计算机中的两个进程，可以使用管道、共享内存、消息队列、信号量等方式进行通信；对于不同计算机中的两个进程，主要使用套接字 (Socket) 进行通信

开发者面向套接字进行网络编程，它是支持 TCP/IP 协议的网络通信基本单元

#### <font color=#9933FF>应用层</font>

应用层是网络应用程序及它们的应用层协议留存的地方。常见的应用程序包括浏览器、邮件、文件传输等，而它们使用的应用层协议分别是 HTTP、SMTP、FTP，还有手机中各种应用程序也算是在应用层实现

假设应用层向下层传递的数据如下图所示：

![2](https://cdn.jsdelivr.net/gh/LFool/new-image-hosting@master/20230523/02195816847795982Aax9b2.svg)

**<font color='red'>注意：</font>**只有应用层是工作在用户态，而其它层都工作在内核态 (传输层及以下)

#### <font color=#9933FF>传输层</font>

传输层在应用程序端点之间传送应用层报文，即：端对端传输，将数据从计算机 A 中的进程 pa 传送到计算机 B 中的进程 pb。在传输层有两个常见的协议：

- **TCP (Transmission Control Protocol)：**面向连接、可靠的数据传输服务，传输单位是报文段 (segment)。它具有流量控制、超时重传、拥塞控制等功能，这些都是为了保证可靠传输
- **UDP (User Datagram Protocol)：**面向无连接、尽最大努力交付的数据传输服务，无法保证可靠，传输单位是用户数据报

这里给出两个限制报文段长度定义：

- **MTU (Maximum Transmission Unit)：**最大传输单元，规定了链路层最大帧长度，也就是「IP 头部 + TCP 头部 + 应用层数据」的最大长度，一般为 1500 字节
- **MSS (Maximum Segment Size)：**最大报文段长度，根据 MTU 可以计算出 TCP 报文段的最大长度，即：1500 - 20 - 20 = 1460 字节

在 TCP 数据传输服务中，假设应用层数据为 3000 字节，那么首先要将 3000 分为 1460、1460、30，然后为每个段添加 TCP 头部，如下图所示：

![3](https://cdn.jsdelivr.net/gh/LFool/new-image-hosting@master/20230523/0257041684781824Cil0r43.svg)

在计算机中每个进程都运行在一个唯一的端口上，传输层提供端到端传输，所以传输层报文中会携带源端口号和目标端口号

#### <font color=#9933FF>网络层</font>

网络层负责将数据报 (datagram) 的网络层分组从一台主机移动到另一台主机。数据报中包含源 IP 和目的 IP 地址，在数据报的传输过程中这两个 IP 始终不会发生改变

网络层的核心设备就是路由器，它的每个端口都有一个网卡，可以配置 IP 地址和 MAC 地址，根据目的 IP 地址可以判断该数据报要从哪个端口转发出去，如果没有匹配的端口就从默认端口转发

确定了转发端口就可以知道下一跳 IP 地址 (中转目标)，然后根据 ARP 协议获取该 IP 地址对应的 MAC 地址，交由下一层 (网络接口层) 将数据传输到下一个节点

**<font color='red'>注意：</font>**如果 IP 数据报大小超过了 MTU，还会继续分片，也就是当「IP 头部 + TCP 头部 + 应用层数据」长度大于 MTU 时！

![4](https://cdn.jsdelivr.net/gh/LFool/new-image-hosting@master/20230523/2039171684845557EUu5Zk4.svg)

网络层不仅会生 IP 头部，而且还会使用 ARP 协议生成 MAC 头部。每次经过路由器，源 MAC 地址会变为路由器接口的 MAC 地址，目的 MAC 地址会变成该下一跳 IP 地址对应的 MAC 地址

**<font color='red'>注意：</font>**

- 虽然有些教材说 MAC 地址属于链路层，确实它属于链路层，可是 MAC 头部却在网络层生成

- 虽然有些教材说 ARP 协议属于网络层，因为网络层使用 ARP 获取了 MAC 地址，但 OSI 标准中规定 ARP 协议属于链路层。可以认为 OSI 模型中 ARP 属于链路层，TCP/IP 模型中 ARP 属于网络层

**更详细可见 [ARP 属于哪层协议](https://blog.csdn.net/ysdaniel/article/details/6785257)**

#### <font color=#9933FF>网络接口层</font>

网络层提到，在数据报传输的过程中源 IP 和目的 IP 地址是不会发生变化滴，那么在传输的过程中如何寻找中间目标呢？？这里就需要在网络接口层使用 MAC 地址将数据报传送给下一个节点

在网络接口层会将 IP 数据报组装成帧 (frame)，添加帧头和帧尾，包含了必要的控制信息，如同步信息、地址信息、差错控制等，在两个相邻节点间的链路上传送帧

![5](https://cdn.jsdelivr.net/gh/LFool/new-image-hosting@master/20230524/02015216848649128YbRbZ5.svg)

### <font color=#1FA774>计算机封装过程</font>

下面给出数据如何从一台计算机的应用程序传送到另一台计算机的应用程序，先看图：

![6](https://cdn.jsdelivr.net/gh/LFool/new-image-hosting@master/20230524/0239171684867157aZXK3q6.svg)

- 在源计算机中，首先从应用层一直向下到网络接口层，一层一层的封装要传输的数据，出了应用层是在用户态下完成，其余都是在内核态完成

- 在交换机中，目前还处于以太网，通过 MAC 地址将数据传送到下一个节点，所以只需要解析网络接口层封装的帧即可

- 在路由器中，通过 IP 地址确定下一跳，所以需要从下往上解析到网络层，获取源 IP 地址和目标 IP 地址，然后确定下一跳 IP 地址，最后获取相应的 MAC 地址，重新封装成 IP 数据包和帧

- 在目的计算机中，从下往上解析到传输层获取应用程序端口号，完成端对端的匹配，最后交给对应的应用程序获取应用层数据

下面给出源计算机如何从应用层一直封装成帧，然后通过网卡将数据发送出去的过程：

![7](https://cdn.jsdelivr.net/gh/LFool/new-image-hosting@master/20230524/0358561684871936sYE0iv7.svg)

注意，在网卡的 MAC 模块中，并不是添加 MAC 头部，而是在开头添加报头和起始帧分界符，在末尾添加用于检测错误的帧校验序列 FCS，如下图所示：

![8](https://cdn.jsdelivr.net/gh/LFool/new-image-hosting@master/20230524/0356471684871807B1tEnW8.svg)

### <font color=#1FA774>动态模拟</font>

**强烈推荐文章 [如果让你来设计网络](https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ)**